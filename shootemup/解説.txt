＜定義＞
内積・外積(A(ax,ay), B(bx,by))
A・B = ax*bx+ay*by
A×B = ax*bx-ay*by

＜定理＞
三平方の定理



θ= min(θ,π/6)


内積記号が・なので、関数名はDot
外積記号が×なので、関数名はCross

外積
A×B = ax*by - ay*bx
外積は、かける順番で結果の符号が変わる。

(1,2)×(6,9)
1*9-2*6 = -3

(6,9)×(1,2)
6*2-9*1 = 3
のように符号が逆になる
A×B = ax*by - ay*bx
B×A = ay*bx - ax*by

A×B = |A||B|sinθ
ax*by-ay*bx
Fcosα*Gsinβ-FsinαGcosβ
FG(cosαsinβ-sinαcosβ)

A×B = sinθ
B×A = -sinθ


listはメモリが連続していない。

vectorは要素の追加と削除が遅い
(メモリが連続しているという利点が制約となり、
あだになっている)

listはメモリが連続しなくてもいい
(連続の恩恵は受けれなくなる)
連続しなくちゃいけないところには使えない
現在の要素に次の要素へのリンクがくっついている
なので、要素を追加する場合は一つだけ確保して
リンクをつなぎなおせばいい

配列：
メリット：簡単、メモリ的に連続している
デメリット：数が決まっている(コンパイル時に決定しないとダメ)

vector：まぁ簡単、
メリット：動的配列にできる(数が実行時にしかわからなくてもOK)
	：メモリ的に連続している
	：追加・削除以外は全コンテナの中でまぁ最速
デメリット：要素の追加・削除・挿入が遅い

list：難しくはない
メリット：連続していないので追加、削除、挿入が比較的に早い
	　　先頭・末尾への追加削除なら最速
デメリット：連続していないので、そのままメモリに書き込めない
	　　　連続してないのでランダムアクセスが遅い

ーわからない人におすすめ戦略ー
まずなんでもvectorで作る。
そして、後で、速度的な問題がでてきたら、listなどを検討してみる